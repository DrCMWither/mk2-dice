<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: src/index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: src/index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { handleHelp      } from "./commands/help.js";
import { handleRoll      } from "./commands/roll.js";
import { handleSt        } from "./commands/st.js";
import { handleRa        } from "./commands/ra.js";
import { handleGetst     } from "./commands/getst.js";
import { handleSynonyms  } from "./commands/syno.js";
import { handleSc        } from "./commands/sc.js";
import { handleLi,
         handleTi        } from "./commands/insanity.js";
import { handleName      } from "./commands/nn.js";
import { handleMessage   } from "./utils/message.js";
import { errorI18n       } from "./utils/etrans.js";
import { handleNnkr      } from "./commands/nnkr.js";
import { handleFastcheck } from "./commands/fsck.js";
import { jrrp            } from "./commands/jrrp.js";


/**
 * Cloudflare Worker entry point for handling Telegram bot updates.
 *
 * This default export object provides a `fetch` handler that:
 * 1. Parses incoming Telegram webhook requests.
 * 2. Extracts the message text, chat ID, user ID, username, and chat title.
 * 3. Matches the message against known bot commands (e.g., /roll, /st, /nn, /li, /ti, /ra, /getst, /syno, /sc, /nnkr, /fsck).
 * 4. Executes the corresponding command handler and sends the reply via `handleMessage`.
 * 5. Handles `/help` commands and paginated help callback queries.
 * 6. Handles errors gracefully and logs relevant messages.
 *
 * @default
 * @property {Function} fetch - The main request handler for the Worker.
 *
 * @param {Request} request - The incoming HTTP request (Telegram webhook POST).
 * @param {Object} env - Environment object containing KV namespaces and other bindings.
 * @param {Object} ctx - Context object provided by Cloudflare Worker runtime.
 *
 * @returns {Promise&lt;Response>} - Always returns a Response with body "OK" or an error status.
 *
 * @example
 * // Deploy as a Cloudflare Worker with the route /telegram-webhook
 * export default { fetch };
 *
 * // Telegram sends a POST request with update JSON
 * // The Worker parses and dispatches to the appropriate command handler
 */
export default {
    async fetch(request, env, ctx) {
        const url = new URL(request.url);
        let update;
        try {
            update = await request.json();
        } catch (err) {
            console.error("[ERROR] Failed to parse JSON:", err);
            return new Response("Invalid JSON", { status: 400 });
        }

        const message  = update.message?.text || "";
        const chatId   = update.message?.chat.id;
        const userId   = update.message?.from.id;

        const from      = update.message?.from || {};
        let   userName  = (from?.last_name || from?.username || from?.first_name || "匿名").toString().trim();
        const chatTitle = update.message?.chat?.title || `群${chatId}`;
        if (userName.length > 32) userName = userName.slice(0, 32) + "...";

        let reply = null;

        const commands = {
            deck:  async () => handleDeck     (env, message, userId, chatId,            userName),
            draw:  async () => handleDraw     (env, message, userId, chatId,            userName),
            jrrp:  async () => jrrp           (env,          userId, chatId,            userName),
            li:    async () => handleLi       (env                                              ),
            nn:    async () => handleName     (env, message, userId, chatId, chatTitle, userName),
            roll:  async () => handleRoll     (env, message, userId, chatId, false,     userName),
            r:     async () => handleRoll     (env, message, userId, chatId, false,     userName),
            rq:    async () => handleRoll     (env, message, userId, chatId, true,      userName),
            ra:    async () => handleRa       (env, message, userId, chatId,            userName),
            rh:    async () => handleRoll     (env, message, userId, null,   false,     userName),
            st:    async () => handleSt       (env, message, userId, chatId, chatTitle          ),
            getst: async () => handleGetst    (env, message, userId, chatId, chatTitle, userName),
            syno:  async () => handleSynonyms (env, message                                     ),
            sc:    async () => handleSc       (env, message, userId, chatId,            userName),
            ti:    async () => handleTi       (env                                              ),
            nnkr:  async () => handleNnkr     (env, message, chatId                             ),
            fsck:  async () => handleFastcheck(                                                 ),
        };

        const helpMatch = message.match(/^\/help(?:@${env.BOT_NAME})?$/);
        if (helpMatch) {
            console.log(`[LOG] Matched /help for chat ${chatId}. Sending help message.`);
            await handleMessage(chatId, handleHelp(0));
        } else {
            const cmdMatch = message.slice(0, 1024).match(/^\/(\w+)(?:@${env.BOT_NAME})?(?:\s+(.+))?$/);
            if (cmdMatch) {
                const cmd = cmdMatch[1];
                if (commands[cmd]) {
                    try {
                        reply = await commands[cmd]();
                        const targetChatId = cmd === "rh" ? userId : chatId;
                        if (reply) {
                            await handleMessage(targetChatId, { text: reply, parse_mode: "HTML" });
                        }
                    } catch (err) {
                        console.error(`[ERROR] Command ${cmd} failed:`, err);
                        await handleMessage(chatId, { text: `命令执行失败，请稍后再试。原因：${err}` });
                    }
                }
            }
        }

        const callback = update.callback_query;
        if (callback?.data?.startsWith("help_")) {
            const pageStr = callback.data.split("_")[1];
            const page = Number(pageStr);
            if (!Number.isInteger(page) || page &lt; 0) {
                console.warn("[WARN] Invalid help page:", pageStr);
                return new Response("OK");
            }
            await handleMessage(
                callback.message.chat.id,
                handleHelp(page),
                { edit: true, messageId: callback.message.message_id }
            );
        }

        return new Response("OK");
    },
};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#bestDiscard">bestDiscard</a></li><li><a href="global.html#clearAllAttributes">clearAllAttributes</a></li><li><a href="global.html#clearAttributes">clearAttributes</a></li><li><a href="global.html#computeWeights">computeWeights</a></li><li><a href="global.html#countMentsu">countMentsu</a></li><li><a href="global.html#countTiles">countTiles</a></li><li><a href="global.html#deleteAttribute">deleteAttribute</a></li><li><a href="global.html#drawTiles">drawTiles</a></li><li><a href="global.html#escapeHtml">escapeHtml</a></li><li><a href="global.html#gammaSample">gammaSample</a></li><li><a href="global.html#gaussian">gaussian</a></li><li><a href="global.html#generateAdvancedProblem">generateAdvancedProblem</a></li><li><a href="global.html#generateDora">generateDora</a></li><li><a href="global.html#generateProblem">generateProblem</a></li><li><a href="global.html#getAllAttributes">getAllAttributes</a></li><li><a href="global.html#getAttributes">getAttributes</a></li><li><a href="global.html#getInsanity">getInsanity</a></li><li><a href="global.html#getQuantumRandomNumbers">getQuantumRandomNumbers</a></li><li><a href="global.html#getSynonyms">getSynonyms</a></li><li><a href="global.html#handToUnicode">handToUnicode</a></li><li><a href="global.html#handleDraw">handleDraw</a></li><li><a href="global.html#handleGetst">handleGetst</a></li><li><a href="global.html#handleInsanity">handleInsanity</a></li><li><a href="global.html#handleLi">handleLi</a></li><li><a href="global.html#handleMessage">handleMessage</a></li><li><a href="global.html#handleName">handleName</a></li><li><a href="global.html#handleNnkr">handleNnkr</a></li><li><a href="global.html#handleRa">handleRa</a></li><li><a href="global.html#handleRoll">handleRoll</a></li><li><a href="global.html#handleSc">handleSc</a></li><li><a href="global.html#handleSt">handleSt</a></li><li><a href="global.html#handleSynonyms">handleSynonyms</a></li><li><a href="global.html#handleTi">handleTi</a></li><li><a href="global.html#improvementCount">improvementCount</a></li><li><a href="global.html#jrrp">jrrp</a></li><li><a href="global.html#nextTile">nextTile</a></li><li><a href="global.html#normalizeKey">normalizeKey</a></li><li><a href="global.html#parseDiceExpression">parseDiceExpression</a></li><li><a href="global.html#randomHand">randomHand</a></li><li><a href="global.html#randomTile">randomTile</a></li><li><a href="global.html#rollDice">rollDice</a></li><li><a href="global.html#setAttribute">setAttribute</a></li><li><a href="global.html#shantenNormal">shantenNormal</a></li><li><a href="global.html#shuffle">shuffle</a></li><li><a href="global.html#sortHand">sortHand</a></li><li><a href="global.html#splitAttributes">splitAttributes</a></li><li><a href="global.html#tileToUnicode">tileToUnicode</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Thu Nov 13 2025 21:20:12 GMT+0800 (China Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
